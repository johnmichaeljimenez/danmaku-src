import os
import glob
from dataclasses import dataclass, field
from typing import List, Dict, Optional

@dataclass
class Instruction:
    opcode: str
    args: List[str] = field(default_factory=list)


@dataclass
class Script:
    name: str
    instructions: List[Instruction] = field(default_factory=list)


def parse_tsv_file(path: str) -> Dict[str, Script]:
    """
    Parse one TSV file into Script objects.

    Syntax:
      #script_name:
      OPCODE<TAB>arg1<TAB>arg2<...>

    - Lines starting with '#' start a new script.
    - All following non-empty lines until next '#' or EOF are instructions.
    """
    scripts: Dict[str, Script] = {}
    current: Optional[Script] = None
    skip = False

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue

            if not skip and not line.startswith("#"):
                skip = True
                continue

            if line.startswith("#"):
                header = line[1:].strip()
                if header.endswith(":"):
                    header = header[:-1].strip()
                name = header
                current = Script(name=name)
                scripts[name] = current
                continue

            if current is None:
                continue

            parts = line.split("\t")
            if not parts:
                continue

            opcode = parts[0].strip()
            args = [p.strip() for p in parts[1:]]
            current.instructions.append(Instruction(opcode=opcode, args=args))

    return scripts


def parse_all_tsv(script_dir: str) -> Dict[str, Script]:
    """
    Parse all .tsv files in the given directory and merge them.
    Later files override earlier ones on name collision.
    """
    all_scripts: Dict[str, Script] = {}
    pattern = os.path.join(script_dir, "*.tsv")
    for path in sorted(glob.glob(pattern)):
        file_scripts = parse_tsv_file(path)
        all_scripts.update(file_scripts)
    return all_scripts

def c_escape_string(s: str) -> str:
    """Escape a Python string as a C string literal."""
    return '"' + s.replace("\\", "\\\\").replace('"', '\\"') + '"'


def instruction_to_c(instr: Instruction) -> str:
    """
    Map Instruction to C initializer:
      { .OPCODE = OP_..., .arg1 = ..., ... .arg8 = ..., .ID1 = ..., .ID2 = ... }

    Rules:
      - Take up to first 8 args as arg1..arg8.
      - 9th arg (if present) becomes ID1 (string literal).
      - 10th arg (if present) becomes ID2 (string literal).
      - Missing arg1..arg8 -> "0"
      - Missing ID1/ID2 -> NULL
      - No type checking: everything is used as-is.
        For arg1..arg8, we *do not* add quotes, so you can pass ints,
        macros, etc. directly in TSV.
    """
    args = instr.args[:] 
    while len(args) < 10:
        args.append("") 

    # arg1..arg8
    arg_values = []
    for i in range(8):
        v = args[i].strip()
        if v == "":
            v = "0"  
        arg_values.append(v)

    # ID1, ID2
    id1_raw = args[8].strip()
    id2_raw = args[9].strip()

    if id1_raw:
        id1 = c_escape_string(id1_raw)
    else:
        id1 = "NULL"

    if id2_raw:
        id2 = c_escape_string(id2_raw)
    else:
        id2 = "NULL"

    arg_parts = [f".arg{i+1} = {arg_values[i]}" for i in range(8)]
    arg_str = ", ".join(arg_parts)

    return f"{{ .OPCODE = {instr.opcode}, {arg_str}, .ID1 = {id1}, .ID2 = {id2} }}"


HEADER_COMMENT = """// This file is auto-generated by bulletscripts.py
// DO NOT EDIT BY HAND

#include "gen_bulletscripts.h"

"""


def generate_c(scripts: Dict[str, Script]) -> str:
    lines: List[str] = []
    lines.append(HEADER_COMMENT)
    lines.append("BulletScript BulletScripts[BULLET_SCRIPT_COUNT] = {")

    for script in scripts.values():
        lines.append("")
        lines.append("    {")
        lines.append(f"        .ID = {c_escape_string(script.name)},")
        lines.append(f"        .Count = {len(script.instructions)},")
        lines.append("        .Instr = {")
        for instr in script.instructions:
            lines.append("            " + instruction_to_c(instr) + ",")
        lines.append("        },")
        lines.append("    },")

    lines.append("};")
    lines.append("")
    return "\n".join(lines)

def main():
    root = os.path.dirname(os.path.abspath(__file__))
    scripts_dir = os.path.join(root, "scripts")
    out_path = os.path.join(root, "src", "gen_bulletscripts.c")

    scripts = parse_all_tsv(scripts_dir)

    if not scripts:
        print("No scripts found in", scripts_dir)
        return

    c_code = generate_c(scripts)

    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(c_code)

    print(f"Generated {out_path} with {len(scripts)} script(s).")


if __name__ == "__main__":
    main()
