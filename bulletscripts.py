import os
import glob
import time
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

@dataclass
class Instruction:
    opcode: str
    args: List[str] = field(default_factory=list)


@dataclass
class Script:
    name: str
    instructions: List[Instruction] = field(default_factory=list)


def parse_tsv_file(path: str) -> Dict[str, Script]:
    """
    Parse one TSV file into Script objects.

    Syntax:
      #script_name:
      OPCODE<TAB>arg1<TAB>arg2<...>

    - Lines starting with '#' start a new script.
    - All following non-empty lines until next '#' or EOF are instructions.
    - All lines starting with -- will be ignored.
    """
    scripts: Dict[str, Script] = {}
    current: Optional[Script] = None
    skip = False

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue

            if line.startswith("--"):
                continue

            if not skip and not line.startswith("#"):
                skip = True
                continue

            if line.startswith("#"):
                header = line[1:].strip()
                if header.endswith(":"):
                    header = header[:-1].strip()
                name = header
                current = Script(name=name)
                scripts[name] = current
                continue

            if current is None:
                continue

            parts = line.split("\t")
            if not parts:
                continue

            opcode = parts[0].strip()
            args = [p.strip() for p in parts[1:]]
            current.instructions.append(Instruction(opcode=opcode, args=args))

    return scripts


def parse_all_tsv(script_dir: str) -> Dict[str, Script]:
    """
    Parse all .tsv files in the given directory and merge them.
    Later files override earlier ones on name collision.
    """
    all_scripts: Dict[str, Script] = {}
    pattern = os.path.join(script_dir, "*.tsv")
    for path in sorted(glob.glob(pattern)):
        file_scripts = parse_tsv_file(path)
        all_scripts.update(file_scripts)
    return all_scripts

def c_escape_string(s: str) -> str:
    """Escape a Python string as a C string literal."""
    return '"' + s.replace("\\", "\\\\").replace('"', '\\"') + '"'


def instruction_to_c(instr: Instruction) -> str:
    """
    Map Instruction to C initializer:
      { .OPCODE = OP_..., .arg1 = ..., ... .arg8 = ..., .ID1 = ..., .ID2 = ... }

    Rules:
      - Take up to first 8 args as arg1..arg8.
      - 9th arg (if present) becomes ID1 (string literal).
      - 10th arg (if present) becomes ID2 (string literal).
      - Missing arg1..arg8 -> "0"
      - Missing ID1/ID2 -> NULL
      - No type checking: everything is used as-is.
        For arg1..arg8, we *do not* add quotes, so you can pass ints,
        macros, etc. directly in TSV.
    """
    args = instr.args[:] 
    while len(args) < 10:
        args.append("") 

    arg_values = [args[i].strip() or "0" for i in range(8)]
    id1 = c_escape_string(args[8].strip()) if args[8].strip() else "NULL"
    id2 = c_escape_string(args[9].strip()) if args[9].strip() else "NULL"

    arg_parts = [f".arg{i+1} = {arg_values[i]}" for i in range(8)]
    return f"{{ .OPCODE = {instr.opcode}, {', '.join(arg_parts)}, .ID1 = {id1}, .ID2 = {id2} }}"


HEADER_COMMENT = """// This file is auto-generated by bulletscripts.py
// DO NOT EDIT BY HAND

#include "gen_bulletscripts.h"

"""


def generate_c(scripts: Dict[str, Script]) -> str:
    lines: List[str] = [HEADER_COMMENT, "BulletScript BulletScripts[BULLET_SCRIPT_COUNT] = {"]
    for script in scripts.values():
        lines.append("")
        lines.append("    {")
        lines.append(f"        .ID = {c_escape_string(script.name)},")
        lines.append(f"        .Count = {len(script.instructions)},")
        lines.append("        .Instr = {")
        for instr in script.instructions:
            lines.append("            " + instruction_to_c(instr) + ",")
        lines.append("        },")
        lines.append("    },")
    lines.append("};\n")
    return "\n".join(lines)


def export_scripts(scripts_dir: str, out_path: str):
    scripts = parse_all_tsv(scripts_dir)
    if not scripts:
        print("No scripts found in", scripts_dir)
        return
    c_code = generate_c(scripts)
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        f.write(c_code)
    print(f"Generated {out_path} with {len(scripts)} script(s).")


class ScriptsEventHandler(FileSystemEventHandler):
    def __init__(self, scripts_dir, out_path):
        super().__init__()
        self.scripts_dir = scripts_dir
        self.out_path = out_path
        self._last_run = 0
        self._debounce = 0.5

    def on_any_event(self, event):
        if event.is_directory:
            return
        if not event.src_path.endswith(".tsv"):
            return
        now = time.time()
        if now - self._last_run < self._debounce:
            return
        self._last_run = now
        print(f"Detected change in {event.src_path}, regenerating scripts...")
        export_scripts(self.scripts_dir, self.out_path)


def main():
    root = os.path.dirname(os.path.abspath(__file__))
    scripts_dir = os.path.join(root, "scripts")
    out_path = os.path.join(root, "src", "gen_bulletscripts.c")

    export_scripts(scripts_dir, out_path)

    print("Watching for changes in", scripts_dir)
    event_handler = ScriptsEventHandler(scripts_dir, out_path)
    observer = Observer()
    observer.schedule(event_handler, scripts_dir, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == "__main__":
    main()
